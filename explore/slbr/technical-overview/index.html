<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SLBr Technical Overview - SLT World</title>
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../modern.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded">
</head>
<body>
    <div class="content">
        <div class="navigation">
            <img src="../../../favicon.png" width="35" height="35" draggable="false">
            <h3>SLT World</h3>
        </div>
        <h1>SLBr Technical Overview</h1>
        <p>A <strong>technical overview</strong> of various SLBr features.</p>
        <div class="container">
            <div class="header">
                <span class="material-symbols-rounded icon">settings</span>
                <p>Internationalized URL Rendering & Homograph Protection</p>
            </div>
            <div style="display: flex;gap: 10px;flex-direction: column;">
                <p>SLBr displays internationalized domain names (IDNs) in a readable Unicode format instead of an encoded Punycode representation.</p>
                <p>This improves readability for users, allowing domains that contain Unicode characters, symbols, or emojis to appear as intended, rather than as encoded "xn--" strings that are difficult for users to interpret.</p>
                <p>However, rendering Unicode domains directly introduced a significant security concern, that is homograph attacks.</p>
                <p>Homograph attacks exploit visually similar characters to create deceptive domain names, such as replacing Latin characters with Cyrillic or Greek characters.</p>
                <p>Examples include:</p>
                <ol class="container">
                    <li><a href="https://vvikipedia.com/" target="_blank" rel="noreferrer nofollow noopener">vvikipedia.com</a></li>
                    <li><a href="https://www.xn--80ak6aa92e.com/" target="_blank" rel="noreferrer nofollow noopener">аррӏе.com</a></li>
                </ol>
                <p>To address this risk, SLBr implemented a homograph detection and highlighting system within the omnibox.</p>
                <p>When potentially confusable or suspicious characters are detected, those characters are highlighted in orange, making them visually distinct from other characters.</p>
                <p>This approach provides several benefits:</p>
                <ol class="container">
                    <li>Internationalized domains remain readable.</li>
                    <li>Suspicious domains become visually noticeable.</li>
                    <li>Users are not forced to interpret encoded Punycode URLs.</li>
                </ol>
                <p>The initial implementation rendered each character of the domain as an individual text run.</p>
                <p>This was inefficient and introduced unnecessary rendering overhead, especially during frequent omnibox updates.</p>
                <p>SLBr now uses a buffered rendering approach:</p>
                <ol class="container">
                    <li>Characters are grouped into segments.</li>
                    <li>Each segment is rendered as a single text run.</li>
                    <li>Suspicious and normal characters are batched separately.</li>
                </ol>
                <p>This significantly reduced the number of UI elements created per update, improving rendering performance.</p>
            </div>
        </div>
        <div class="container">
            <div class="header">
                <span class="material-symbols-rounded icon">settings</span>
                <p>Multi-Engine Architecture</p>
            </div>
            <div style="display: flex;gap: 10px;flex-direction: column;">
                <p>SLBr supports multiple web engines through a unified abstraction layer.</p>
                <p>Rather than binding SLBr directly to a specific web engine, SLBr treats each engine as an implementation behind a shared interface.</p>
                <p>This allows the browser core to remain engine-agnostic while still supporting different web engines.</p>

                <p>Earlier versions of SLBr implemented multi-engine support through conditional logic.</p>
                <p>Multiple web engines such as CefSharp (Chromium), WebView2 (Microsoft Edge), and WebBrowser (Internet Explorer) were used directly throughout the codebase without a shared interface.</p>
                <p>This approach resulted in several issues:</p>
                <ol class="container">
                    <li>Extensive engine-specific conditionals scattered across the codebase.</li>
                    <li>Tight coupling between browser logic and individual engines.</li>
                    <li>Poor maintainability and limited extensibility.</li>
                    <li>Increasing difficulty adding new features or engines while maintaining parity.</li>
                </ol>
                <p>As development continued, the code quickly became a complex and unmanageable set of engine-specific cases.</p>
                <p>Due to these issues, the multi-engine feature was effectively shelved for a period of time, as maintaining feature parity and stability across engines became impractical without a fundamental redesign.</p>
                <p>In addition, engine features became highly inconsistent. The conditional-based implementation often resulted in features being developed primarily for a single engine, while other engines received incomplete or no support.</p>

                <p>To resolve these issues, SLBr now uses an adapter-based architecture to support multiple web engines.</p>
                <p>Each web engine is wrapped by an adapter that translates engine-specific APIs into a shared interface.</p>
                <p>The browser core interacts with the engines through a single interface, remaining mostly unaware of which engine is currently in use.</p>
                <p>This architecture provides several benefits:</p>
                <ol class="container">
                    <li>Engine-specific behavior is fully isolated.</li>
                    <li>New engines can be added without extensively modifying existing browser logic.</li>
                    <li>Conditional engine checks are largely eliminated.</li>
                    <li>Overall codebase remains clean and maintainable.</li>
                    <li>Feature parity is significantly improved.</li>
                </ol>
                <p>As a result, SLBr can more easily support additional engines in the future, such as GeckoFX, Ultralight, or other web engine implementations.</p>

                <p>The new architecture also enabled proper handling of custom protocol schemes such as gemini://, gopher://, and slbr:// across different web engines.</p>
                <p>Under the previous conditional-based implementation, adding protocol support across multiple engines was impractical due to deeply intertwined engine-specific logic.</p>
                <p>With the new architecture, protocol handling is centralized and applied consistently, making it significantly easier to extend and maintain.</p>

                <p>Despite the architectural improvements, not all web engines provide the same level of functionality.</p>
                <p>Some limitations include:</p>
                <ol class="container">
                    <li>Extension support is not fully standardized.</li>
                    <li>Certain features, such as downloads and popups, behave inconsistently.</li>
                    <li>Legacy web engines like Internet Explorer lack many modern web capabilities.</li>
                </ol>
                <p>These constraints are inherent to the underlying engines themselves rather than the architecture.</p>
            </div>
        </div>
        <div class="container">
            <div class="header">
                <span class="material-symbols-rounded icon">settings</span>
                <p>Internal Pages & Overlay Architecture</p>
            </div>
            <div style="display: flex;gap: 10px;flex-direction: column;">
                <p>In SLBr, specific internal browser pages relies on C# and XAML, rather than HTML and Javascript.</p>
                <p>Relying on HTML and JavaScript posed technical challenges in a multi-engine architecture, as behavior varied between web engines.</p>

                <p>In early versions of SLBr, the Settings page was implemented as a special standalone tab, rather than a navigable page.</p>
                <p>Users could not access it via a URL such as <code style="display: inline-block;">slbr://setting</code>, and the tab system required custom handling to support this exception.</p>
                <p>This approach resulted in several issues:</p>
                <ol class="container">
                    <li>Internal pages were not navigable.</li>
                    <li>Further complicated tab system due to special-case handling.</li>
                    <li>Inconsistent behavior between web engines.</li>
                </ol>
                <p>As a result, a new approach was introduced to integrate internal pages with the browser's navigation model.</p>
                <p>SLBr now uses an overlay-based page system, where internal pages are implemented as User Controls rendered on top of the web view.</p>
                <p>From a user's perspective, these pages behave like normal navigable URLs, while internally they are rendered natively using WPF rather than HTML.</p>
                <p>This approach provides several advantages:</p>
                <ol class="container">
                    <li>Internal pages are fully navigable.</li>
                    <li>No special tab logic required.</li>
                    <li>Internal pages can be developed using C# and XAML.</li>
                    <li>Behavior remains consistent across all web engines.</li>
                    <li>Avoids exposing privileged browser information to JavaScript.</li>
                </ol>
                <p>Because the overlay is engine-agnostic, it integrates cleanly with the existing multi-engine abstraction layer and avoids relying on engine-specific HTML and JavaScript capabilities.</p>
                <p>Following the success of the Settings page, other internal pages such as History were also migrated from HTML/JavaScript implementations to native WPF overlays.</p>
                <p>This transition provides several benefits:</p>
                <ol class="container">
                    <li>Simplified development and improved internal integration.</li>
                    <li>Browser information can be accessed directly without polling or scripting bridges.</li>
                    <li>UI updates react immediately to changes.</li>
                    <li>Instant loading for instant pages.</li>
                </ol>
                <p>This approach results in a cleaner, more maintainable design, while still presenting internal pages as part of a smooth browsing experience.</p>
            </div>
        </div>
        <div class="container">
            <div class="header">
                <span class="material-symbols-rounded icon">settings</span>
                <p>Spellcheck Architecture</p>
            </div>
            <div style="display: flex;gap: 10px;flex-direction: column;">
                <p>Early versions of SLBr relied directly on the built-in spellcheck functionality provided by CefSharp.</p>
                <p>This approach was simple, providing spellchecking without complexity.</p>
                <p>However, a later Chromium update introduced changes that broke the built-in spellcheck.</p>
                <p>As a result, spellchecking functionality became unavailable for a period of time.</p>

                <p>To restore spellchecking support, SLBr transitioned to an engine-agnostic, cloud-based solution.</p>
                <p>SLBr used an on-demand request model rather than performing continuous, real-time spellchecking.</p>
                <p>Spellcheck requests are only triggered when text is selected and the context menu is opened.</p>
                <p>This design introduced several benefits:</p>
                <ol class="container">
                    <li>Lower request amount compared to traditional real-time spellcheckers.</li>
                    <li>Significantly reduced bandwidth usage.</li>
                    <li>Reduced risk of password leakage since text is not transmitted while typing.</li>
                    <li>Consistent behavior across all web engines.</li>
                </ol>
                <p>Despite these advantages, this approach had notable issues:</p>
                <ol class="container">
                    <li>Spellchecking required an active internet connection.</li>
                    <li>Sending requests introduced privacy concerns.</li>
                    <li>Dependence on an external service.</li>
                    <li>Increased bandwidth usage.</li>
                </ol>
                <p>To address these issues, SLBr added a spellchecking provider based on WPF's built-in spellchecker.</p>
                <p>This provider contains several advantages:</p>
                <ol class="container">
                    <li>Operates on the client side.</li>
                    <li>Instant spellcheck results.</li>
                    <li>Remains functional without an internet connection.</li>
                    <li>Improved responsiveness when opening context menus.</li>
                </ol>
                <p>This option significantly improves performance and reliability for common use cases.</p>
                <p>During further development, Microsoft Edge's cloud-based spellchecker was discovered and integrated as an additional provider.</p>
            </div>
        </div>
    </div>
</body>
</html>