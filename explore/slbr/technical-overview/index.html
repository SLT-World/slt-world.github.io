<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>SLBr Technical Overview - SLT World</title>
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../../modern.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded">
</head>
<body>
    <div class="content">
        <div class="navigation">
            <img src="../../../favicon.png" width="35" height="35" draggable="false">
            <h3>SLT World</h3>
        </div>
        <h1>SLBr Technical Overview</h1>
        <p>A <strong>technical overview</strong> of various SLBr features.</p>
        <div class="container">
            <div class="header">
                <span class="material-symbols-rounded icon">settings</span>
                <p>Internationalized URL Rendering & Homograph Protection</p>
            </div>
            <div style="display: flex;gap: 10px;flex-direction: column;">
                <p>SLBr displays internationalized domain names (IDNs) in a readable Unicode format instead of an encoded Punycode representation.</p>
                <p>This improves readability for users, allowing domains that contain Unicode characters, symbols, or emojis to appear as intended, rather than as encoded "xn--" strings that are difficult for users to interpret.</p>
                <p>However, rendering Unicode domains directly introduced a significant security concern, that is homograph attacks.</p>
                <p>Homograph attacks exploit visually similar characters to create deceptive domain names, such as replacing Latin characters with Cyrillic or Greek characters.</p>
                <p>Examples include:</p>
                <ol class="container">
                    <li><a href="https://vvikipedia.com/" target="_blank" rel="noreferrer nofollow noopener">vvikipedia.com</a></li>
                    <li><a href="https://www.xn--80ak6aa92e.com/" target="_blank" rel="noreferrer nofollow noopener">аррӏе.com</a></li>
                </ol>
                <p>To address this risk, SLBr implemented a homograph detection and highlighting system within the omnibox.</p>
                <p>When potentially confusable or suspicious characters are detected, those characters are highlighted in orange, making them visually distinct from other characters.</p>
                <p>This approach provides several benefits:</p>
                <ol class="container">
                    <li>Internationalized domains remain readable.</li>
                    <li>Suspicious domains become visually noticeable.</li>
                    <li>Users are not forced to interpret encoded Punycode URLs.</li>
                </ol>
                <p>The initial implementation rendered each character of the domain as an individual text run.</p>
                <p>This was inefficient and introduced unnecessary rendering overhead, especially during frequent omnibox updates.</p>
                <p>SLBr now uses a buffered rendering approach:</p>
                <ol class="container">
                    <li>Characters are grouped into segments.</li>
                    <li>Each segment is rendered as a single text run.</li>
                    <li>Suspicious and normal characters are batched separately.</li>
                </ol>
                <p>This significantly reduced the number of UI elements created per update, improving rendering performance.</p>
            </div>
        </div>
        <div class="container">
            <div class="header">
                <span class="material-symbols-rounded icon">settings</span>
                <p>Multi-Engine Architecture</p>
            </div>
            <div style="display: flex;gap: 10px;flex-direction: column;">
                <p>SLBr supports multiple web engines through a unified abstraction layer.</p>
                <p>Rather than binding SLBr directly to a specific web engine, SLBr treats each engine as an implementation behind a shared interface.</p>
                <p>This allows the browser core to remain engine-agnostic while still supporting different web engines.</p>

                <p>Earlier versions of SLBr implemented multi-engine support through conditional logic.</p>
                <p>Multiple web engines such as CefSharp (Chromium), WebView2 (Microsoft Edge), and WebBrowser (Internet Explorer) were used directly throughout the codebase without a shared interface.</p>
                <p>This approach resulted in several issues:</p>
                <ol class="container">
                    <li>Extensive engine-specific conditionals scattered across the codebase.</li>
                    <li>Tight coupling between browser logic and individual engines.</li>
                    <li>Poor maintainability and limited extensibility.</li>
                    <li>Increasing difficulty adding new features or engines while maintaining parity.</li>
                </ol>
                <p>As development continued, the code quickly became a complex and unmanageable set of engine-specific cases.</p>
                <p>Due to these issues, the multi-engine feature was effectively shelved for a period of time, as maintaining feature parity and stability across engines became impractical without a fundamental redesign.</p>
                <p>In addition, engine features became highly inconsistent. The conditional-based implementation often resulted in features being developed primarily for a single engine, while other engines received incomplete or no support.</p>

                <p>To resolve these issues, SLBr now uses an adapter-based architecture to support multiple web engines.</p>
                <p>Each web engine is wrapped by an adapter that translates engine-specific APIs into a shared interface.</p>
                <p>The browser core interacts with the engines through a single interface, remaining mostly unaware of which engine is currently in use.</p>
                <p>This architecture provides several benefits:</p>
                <ol class="container">
                    <li>Engine-specific behavior is fully isolated.</li>
                    <li>New engines can be added without extensively modifying existing browser logic.</li>
                    <li>Conditional engine checks are largely eliminated.</li>
                    <li>Overall codebase remains clean and maintainable.</li>
                    <li>Feature parity is significantly improved.</li>
                </ol>
                <p>As a result, SLBr can more easily support additional engines in the future, such as GeckoFX, Ultralight, or other web engine implementations.</p>

                <p>The new architecture also enabled proper handling of custom protocol schemes such as gemini://, gopher://, and slbr:// across different web engines.</p>
                <p>Under the previous conditional-based implementation, adding protocol support across multiple engines was impractical due to deeply intertwined engine-specific logic.</p>
                <p>With the new architecture, protocol handling is centralized and applied consistently, making it significantly easier to extend and maintain.</p>

                <p>Despite the architectural improvements, not all web engines provide the same level of functionality.</p>
                <p>Some limitations include:</p>
                <ol class="container">
                    <li>Extension support is not fully standardized.</li>
                    <li>Certain features, such as downloads and popups, behave inconsistently.</li>
                    <li>Legacy web engines like Internet Explorer lack many modern web capabilities.</li>
                </ol>
                <p>These constraints are inherent to the underlying engines themselves rather than the architecture.</p>
            </div>
        </div>
    </div>
</body>
</html>